24OCT21

I've already written up a bunch of logic - and I've hardly done anything in Unity at all except import some sprites from an asset pack I bought a while back for $8. 
TDD really helps me come up with the logic I need. A lot of times I find myself staring at a blank page trying to think of how to encompass all the logic for a 
particular aspect of a game into code - but I'm finding that the slow, steady, iterative process TDD pushes you into let's you slowly build that logic up into a 
meaningful algorithm that you can then refactor and clean up really nice. It's also giving me a deeper insight into how my game is structured - and forces me to use 
additional layers of abstraction that I probably would'nt have recognized the need for otherwise.

I've written up all six types of chess pieces as extensions of the abstract ChessPiece class - with the Queen, Bishop, and Rook extending the GlidingPiece class which 
extends ChessPiece (this let's them share the logic for diagonal/vertical/horizontal moves and checking for other pieces blocking their path). I'm conciously constructing 
a lot of the logic behind the fact that I later plan to add a Minimax algorithm for a computer player - so I've created a Move class that includes the piece, its 
destination, its legality, a few other useful tidbits, and the ability to execute or undo the move. Since Undo is a big part of Minimax - I suspect this will be useful 
later. I could also add a feature to let the player undo their moves and try different strategies.

26OCT21

Some of things I like about TDD so far is that it's pushing me to use more abstraction and better structure in my code. Whereas I might have normally depending on Unity 
MonoBehaviours to hold most of the data and logic, I've found that it's not actually too difficult to separate the game rules and logic from the player interface. I'm not 
sure if this is MVC or some variation of it (I'd probably need to understand more about MVC to make that determination) but it *sounds* like MVC - with the Model being 
my ChessPiece classes and ChessBoard class, and the View being the associated behaviour classes - and I presume the controller will be the player input logic I have yet 
to implement. I also like that I can comfortably refactor without worrying about whether I will break things - I just keep rerunning the tests after every change to 
make sure. There have been a couple times where things have broken in places I didn't expect after a refactor - and while sometimes it's related to the way I set up 
those tests, it has also kept me from making mistakes that might have otherwise taken me quite some time to figure out.

One of the things I don't like is that it's somewhat encouraging me to make more public properties and methods. I've done a little reading online about this and the 
general consensus is that you should really only be testing the methods and properties with which other parts of your code will interface. However, I find that following 
the three rules of TDD - writing just enough code to pass a test means returning the results quickly and easily - and therefore publicly. I'm probably microtesting 
though - this may just need to be one of those things I improve upon with experience.

As I begin to write Play Mode unit tests, I'm beginning to see the challenges associated with TDD in Unity. I believe I can still manage it - but I do feel like I'm 
working around some of unity's features in order to make my tests work. For example - pulling in a prefab with Resources.Load instead of assigning it in the inspector 
(so that I can create a gameobject that would have had a reference in its inspector, rather than do a OneTimeLoad). I'm not sure if this is a good thing or not.

I have also begun to realize that I need to apply my same level of design scrutiny to my tests as well as my code - my tests have been throwing some DRY flags in my 
face but I've been ignoring them since they're just tests - but I think I should take some time to refactor my tests as well as my code.
